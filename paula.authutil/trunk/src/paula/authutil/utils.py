# Copyright (c) 2008 by Florian Friesdorf
#
# GNU Affero General Public License (AGPL)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
"""
"""
__author__ = "Florian Friesdorf <flo@chaoflow.net>"
__docformat__ = "plaintext"

from BTrees import OOBTree
from persistent import Persistent

from zope.app.container.contained import Contained

from zope.component import queryUtility
from zope.component.interfaces import IFactory

from zope.interface import implements

from paula.authentication.interfaces import IAuthProvider

from paula.authutil.interfaces import IRWAuthProviders
from paula.authutil.interfaces import PrincipalIdAlreadyTaken


class RWAuthProviders(Persistent, Contained):
    """Utility delivering IAuthProvider for principal ids

    IAuthProvider objects are generated by dynamic adapter lookup from
    IAuthProviderAdaptable objects, which are retrieved from an internal
    mapping. Objects enter/leave the mapping through register/unregister.

    Currently we do not support modification of principal id for registered
    objects; before doing anything that modifies the prinicipal id of an object,
    you need to unregister and reregister the object.

    Currently, we maintain a two-way mapping, having a feeling that this comes
    in handy, in case of ObjectModifiedEvents, which might overcome the
    limitation about not changing registered objects. It is already used to
    prevent unregistered objects with the same principal id as an registered
    object, to remove the latter's mapping, when being passed to unregister.

    This utility should be registered as a local utility, you probably want
    the persistent version (see below).

    This utility could be registered globally and works outside of an
    application server. However, the adapter lookup for IAuthProvider needs
    to be supported.


    Mappings are empty, for a new utility

        >>> apu = RWAuthProviders()
        >>> len(apu._ids)
        0
        >>> len(apu._objs)
        0
        >>> len(apu)
        0

    Suitable object ends up in both mappings, strings work as id

        >>> a = Mock(id = '1')
        >>> alsoProvides(a, IAuthProvider)
        >>> apu.register(a)
        >>> len(apu._ids)
        1
        >>> len(apu._objs)
        1
        >>> len(apu)
        1
        >>> apu._ids[a] is '1'
        True
        >>> apu._objs['1'] is a
        True

    Object with same id as registered object triggers PrincipalIdAlreadyTaken

        >>> b = Mock(id = '1')
        >>> alsoProvides(b, IAuthProvider)
        >>> apu.register(b)
        Traceback (most recent call last):
            blah
        PrincipalIdAlreadyTaken: 1

    Unsuitable object triggers TypeError

        >>> b = Mock(id = '2')
        >>> apu.register(b) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
            blah
        TypeError: blah

    More than one object can be added

        >>> b = Mock(id = '2')
        >>> alsoProvides(b, IAuthProvider)
        >>> apu.register(b)
        >>> len(apu._ids)
        2
        >>> len(apu._objs)
        2

    Objects are retrieved correctly
        
        >>> apu['1'] is a
        True
        >>> apu['2'] is b
        True
    """
    implements(IRWAuthProviders)

    def __init__(self):
        """
        """
        # XXX:
        # self might be stored in a persistent container
        # _ids and _objs are our only attributes and they won't change
        # I assume it is enough that the BTrees are persistent and that self
        # does not need to be...
        self._ids = queryUtility(IFactory, 'OOBTree', OOBTree.OOBTree)()
        self._objs = queryUtility(IFactory, 'OOBTree', OOBTree.OOBTree)()

    def __contains__(self, id):
        return self.has_key(id)

    def __getitem__(self, id):
        """get IAuthProvider object for principal id
        """
        obj = self._objs[id]
        ap = IAuthProvider(obj)
        return ap

    def __len__(self):
        return self._ids.__len__()

    def has_key(self, id):
        # I currently consider this a broken BTree
        return bool(self._objs.has_key(id))

    def keys(self):
        # I currently consider this a broken BTree
        return list(self._objs.keys())

    def register(self, obj):
        """Register an object.

        It is assumed that an adapter lookup for IAuthProvider succeeds.

        Fails with PrincipalIdAlreadyTaken, in case an object with the same
        principal id is registered already.
        """
        id = IAuthProvider(obj).id
        if self._objs.has_key(id):
            if self._objs[id] is not obj:
                raise PrincipalIdAlreadyTaken, id
            return
        self._objs[id] = obj
        self._ids[obj] = id
        #notify(AuthProviderAdded(ob, event))

    def unregister(self, obj):
        """Unregister an object.

        Fails with KeyError, if the object is not registered.
        """
        # get id for obj, implicit check that obj is registered
        id = self._ids[obj]
        del self._objs[id]
        del self._ids[obj]
        #notify(AuthProviderRemoved(ob, event))
