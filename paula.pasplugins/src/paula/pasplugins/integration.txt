paula.pasplugins integration test
=================================

Supposed to test integration with Plone and PAU.


PAU is up and running with our real and fake plugins
----------------------------------------------------

First of all, there should be a PAU and it should know about the credentials
plugin:

    >>> from zope.app.authentication.interfaces import \
    ...		IPluggableAuthentication
    >>> from zope.app.authentication.interfaces import \
    ...		ICredentialsPlugin
    >>> from paula.pasplugins.plugins.paucred import CREDPLUG_NAME

    >>> pau = getUtility(IPluggableAuthentication)
    >>> CREDPLUG_NAME in pau.credentialsPlugins
    True

    >>> credplug = getUtility(ICredentialsPlugin, name=CREDPLUG_NAME)
    >>> credplugs = list( pau.getCredentialsPlugins() )
    >>> len(credplugs)
    1
    >>> credplugs[0][0] == CREDPLUG_NAME
    True
    >>> credplugs[0][1] is credplug
    True


For further testing we use a fake authenticator plugin:

    >>> from zope.app.authentication.interfaces import \
    ...		IAuthenticatorPlugin
    >>> from paula.pasplugins.tests.fake_pau_ap import AUTHPLUG_NAME
    >>> from paula.pasplugins.tests.fake_pau_ap import AuthenticatorPlugin

    >>> len(pau.authenticatorPlugins)
    0

    >>> authplug = getUtility(IAuthenticatorPlugin, name=AUTHPLUG_NAME)
    >>> pau.authenticatorPlugins = (AUTHPLUG_NAME,)
    >>> authplugs = list( pau.getAuthenticatorPlugins() )
    >>> len(authplugs)
    1
    >>> authplugs[0][0] == AUTHPLUG_NAME
    True
    >>> authplugs[0][1] is authplug
    True


Ok, it should be possible to authenticate with PAU, using the credentials
for the fake user:

    >>> pau.authenticate(None)
    Traceback (most recent call last):
    ...
    AttributeError: ...

    >>> pau.authenticate(UserDict(login='foo',password='foo')) is None
    True

    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_REQUEST
    >>>	principal = pau.authenticate(FAKE_REQUEST)
    >>> principal.id is 'fakelogin'
    True

The user carries groups and properties provided by our fake testing
subscribers:

    >>> principal.email
    u'foo@bar.com'
    >>> principal.realname
    u'fake user'
    >>> principal.foo
    u'foo value'
    >>> principal.groups
    ['fakegroup1', 'fakegroup2']


The user should also be returned for a getPrincipal call:

    >>> principal2 = pau.getPrincipal('fakelogin')
    >>> principal2.id
    'fakelogin'
    >>> principal2.email
    u'foo@bar.com'
    >>> principal2.realname
    u'fake user'
    >>> principal2.foo
    u'foo value'
    >>> principal2.groups
    ['fakegroup1', 'fakegroup2']


PAU is working as expected.


The PAS plugins
---------------

    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_CREDS
    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_LOGIN
    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_PASSWORD

Paula PAS auth plugin

    >>> p = portal.acl_users.paula_auth.authenticateCredentials(FAKE_CREDS)
    >>> p
    ('fakelogin', 'fakelogin')

make a plone user

    >>> from Products.PlonePAS.plugins.ufactory import PloneUser
    >>> pu = PloneUser(p[1])
    >>> pu
    <PloneUser 'fakelogin'>

Paula PAS properties plugin - the order might be unstable

    >>> psheet = portal.acl_users.paula_properties.getPropertiesForUser(pu)
    >>> psheet.propertyItems()[0]
    ('foo', u'foo value')
    >>> psheet.propertyItems()[1]
    ('email', u'foo@bar.com')
    >>> psheet.propertyItems()[2]
    ('realname', u'fake user')
    
Paula PAS group plugin

    >>> portal.acl_users.paula_groups.getGroupsForPrincipal(pu)
    ('fakegroup1', 'fakegroup2')


Walk through the PAS API
------------------------

    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_LOGIN
    >>> pas = portal.acl_users

These are currently the same and unsupported

XXX: IUserEnumerationPlugin support needed!

    >>> pas.getUser(FAKE_LOGIN)
    >>> pas.getUserById(FAKE_LOGIN)

#    >>> from Products.PluggableAuthService.tests.test_PluggableAuthService \
#    ...		import RequestCleaner, FauxResponse
#    >>> rc = RequestCleaner()
#    >>> request = rc._makeRequest(
#    ...		RESPONSE=FauxResponse(),
#    ...		form=FAKE_CREDS,
#    ...		)

#    >>> from zope.publisher.browser import TestRequest
#    >>> request = TestRequest(form=FAKE_CREDS)
#    >>> pas.validate(request)

#    >>> from Testing.makeRequest import makeRequest
#    >>> interact( locals() )
#
#    >>> pas.searchUsers()
#    >>> pas.searchGroups()
#    >>> pas.searchPrincipals()





Set things up (thx optilux)
---------------------------

    >>> from Products.Five.testbrowser import Browser
    >>> browser = Browser()
    >>> portal_url = self.portal.absolute_url()

The following is useful when writing and debugging testbrowser tests. It lets
us see error messages properly.

    >>> browser.handleErrors = False
    >>> self.portal.error_log._ignored_exceptions = ()

We then turn off the various portlets, because they sometimes duplicate links
and text (e.g. the navtree, the recent recent items listing) that we wish to
test for in our own views. Having no portlets makes things easier.

    >>> from zope.component import getMultiAdapter, getUtility
    >>> from plone.portlets.interfaces import IPortletManager
    >>> from plone.portlets.interfaces import IPortletAssignmentMapping

    >>> left_column = getUtility(IPortletManager, name=u"plone.leftcolumn")
    >>> left_assignable = getMultiAdapter(
    ...		(self.portal, left_column),
    ...		IPortletAssignmentMapping,
    ...		)
    >>> for name in left_assignable.keys():
    ...     del left_assignable[name]

    >>> right_column = getUtility(IPortletManager, name=u"plone.rightcolumn")
    >>> right_assignable = getMultiAdapter(
    ...		(self.portal, right_column),
    ...		IPortletAssignmentMapping,
    ...		)
    >>> for name in right_assignable.keys():
    ...     del right_assignable[name]


add a "regular" user

#    >>> portal.acl_users.source_users.addUser('honk', 'honk', 'honk')
#    >>> browser.open(portal_url + '/login_form?came_from=' + portal_url)
#    >>> browser.getControl(name='__ac_name').value = 'honk'
#    >>> browser.getControl(name='__ac_password').value = 'honk'
#    >>> browser.getControl(name='submit').click()
#
#    >>> interact( locals() )

try to authenticate

#    >>> browser.open(portal_url + '/login_form?came_from=' + portal_url)
#    >>> browser.getControl(name='__ac_name').value = FAKE_LOGIN
#    >>> browser.getControl(name='__ac_password').value = FAKE_PASSWORD+'foo'
#    >>> browser.getControl(name='submit').click()
#    >>> 'Login failed' in browser.contents
#    True

    >>> interact( locals() )

    >>> browser.open(portal_url + '/login_form?came_from=' + portal_url)
    >>> browser.getControl(name='__ac_name').value = FAKE_LOGIN
    >>> browser.getControl(name='__ac_password').value = FAKE_PASSWORD
    >>> browser.getControl(name='submit').click()

    >>> interact( locals() )
