paula.pasplugins integration test
=================================

Supposed to test integration with Plone and PAU.


PAU is up and running with our real and fake plugins
----------------------------------------------------

First of all, there should be a PAU and it should know about the credentials
plugin:

    >>> from zope.app.authentication.interfaces import \
    ...		IPluggableAuthentication
    >>> from zope.app.authentication.interfaces import \
    ...		ICredentialsPlugin
    >>> from paula.pasplugins.plugins.paucred import CREDPLUG_NAME

    >>> pau = getUtility(IPluggableAuthentication)
    >>> CREDPLUG_NAME in pau.credentialsPlugins
    True

    >>> credplug = getUtility(ICredentialsPlugin, name=CREDPLUG_NAME)
    >>> credplugs = list( pau.getCredentialsPlugins() )
    >>> len(credplugs)
    1
    >>> credplugs[0][0] == CREDPLUG_NAME
    True
    >>> credplugs[0][1] is credplug
    True


For further testing we use a fake authenticator plugin:

    >>> from zope.app.authentication.interfaces import \
    ...		IAuthenticatorPlugin
    >>> from paula.pasplugins.tests.fake_pau_ap import AUTHPLUG_NAME
    >>> from paula.pasplugins.tests.fake_pau_ap import AuthenticatorPlugin

    >>> len(pau.authenticatorPlugins)
    0

    >>> authplug = getUtility(IAuthenticatorPlugin, name=AUTHPLUG_NAME)
    >>> pau.authenticatorPlugins = (AUTHPLUG_NAME,)
    >>> authplugs = list( pau.getAuthenticatorPlugins() )
    >>> len(authplugs)
    1
    >>> authplugs[0][0] == AUTHPLUG_NAME
    True
    >>> authplugs[0][1] is authplug
    True


Ok, it should be possible to authenticate with PAU, using the credentials
for the fake user:

    >>> pau.authenticate(None)
    Traceback (most recent call last):
    ...
    AttributeError: ...

    >>> pau.authenticate(UserDict(login='foo',password='foo')) is None
    True

    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_REQUEST
    >>>	principal = pau.authenticate(FAKE_REQUEST)
    >>> principal.id is 'fakelogin'
    True

The user carries groups and properties provided by our fake testing
subscribers:

    >>> principal.email
    u'foo@bar.com'
    >>> principal.realname
    u'fake user'
    >>> principal.foo
    u'foo value'
    >>> principal.groups
    ['fakegroup1', 'fakegroup2']


The user should also be returned for a getPrincipal call:

    >>> principal2 = pau.getPrincipal('fakelogin')
    >>> principal2.id
    'fakelogin'
    >>> principal2.email
    u'foo@bar.com'
    >>> principal2.realname
    u'fake user'
    >>> principal2.foo
    u'foo value'
    >>> principal2.groups
    ['fakegroup1', 'fakegroup2']


PAU is working as expected.


The PAS plugins
---------------

    >>> from paula.pasplugins.tests.fake_pau_ap import FAKE_CREDS

Paula PAS auth plugin

    >>> p = portal.acl_users.paula_auth.authenticateCredentials(FAKE_CREDS)
    >>> p
    ('fakelogin', 'fakelogin')

make a plone user

    >>> from Products.PlonePAS.plugins.ufactory import PloneUser
    >>> pu = PloneUser(p[1])
    >>> pu
    <PloneUser 'fakelogin'>

Paula PAS properties plugin - the order might be unstable

    >>> psheet = portal.acl_users.paula_properties.getPropertiesForUser(pu)
    >>> psheet.propertyItems()[0]
    ('foo', u'foo value')
    >>> psheet.propertyItems()[1]
    ('email', u'foo@bar.com')
    >>> psheet.propertyItems()[2]
    ('realname', u'fake user')
    
Paula PAS group plugin

    >>> portal.acl_users.paula_groups.getGroupsForPrincipal(pu)
    ('fakegroup1', 'fakegroup2')


A login should be possible
--------------------------







#Set things up (thx optilux)
#---------------------------
#
#    >>> from Products.Five.testbrowser import Browser
#    >>> browser = Browser()
#    >>> portal_url = self.portal.absolute_url()
#
#The following is useful when writing and debugging testbrowser tests. It lets
#us see error messages properly.
#
#    >>> browser.handleErrors = False
#    >>> self.portal.error_log._ignored_exceptions = ()
#
#We then turn off the various portlets, because they sometimes duplicate links
#and text (e.g. the navtree, the recent recent items listing) that we wish to
#test for in our own views. Having no portlets makes things easier.
#
#    >>> from zope.component import getMultiAdapter, getUtility
#    >>> from plone.portlets.interfaces import IPortletManager
#    >>> from plone.portlets.interfaces import IPortletAssignmentMapping
#
#    >>> left_column = getUtility(IPortletManager, name=u"plone.leftcolumn")
#    >>> left_assignable = getMultiAdapter((self.portal, left_column), IPortletAssignmentMapping)
#    >>> for name in left_assignable.keys():
#    ...     del left_assignable[name]
#
#    >>> right_column = getUtility(IPortletManager, name=u"plone.rightcolumn")
#    >>> right_assignable = getMultiAdapter((self.portal, right_column), IPortletAssignmentMapping)
#    >>> for name in right_assignable.keys():
#    ...     del right_assignable[name]
#
#
#Start testing
#-------------
#
#
#
#try to authenticate
#
#    >>> browser.open(portal_url + '/login_form?came_from=' + portal_url)
#    >>> browser.getControl(name='__ac_name').value = u"user"
#    >>> browser.getControl(name='__ac_password').value = u"wrong"
#    >>> browser.getControl(name='submit').click()
#    >>> 'Login failed' in browser.contents
#    True
#
#    >>> browser.open(portal_url + '/login_form?came_from=' + portal_url)
#    >>> browser.getControl(name='__ac_name').value = u"user"
#    >>> browser.getControl(name='__ac_password').value = u"password"
#    >>> browser.getControl(name='submit').click()
#    >>> 'Login failed' in browser.contents
#    False
