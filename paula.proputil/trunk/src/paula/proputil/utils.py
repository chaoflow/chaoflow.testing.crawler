# Copyright (c) 2008 by Florian Friesdorf
#
# GNU Affero General Public License (AGPL)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
"""
"""
__author__ = "Florian Friesdorf <flo@chaoflow.net>"
__docformat__ = "plaintext"

from BTrees import OOBTree

from persistent import Persistent
from persistent.list import PersistentList

from zope.app.container.contained import Contained

from zope.component import queryUtility
from zope.component.interfaces import IFactory

from zope.interface import implements

from paula.properties.interfaces import IPropertyProvider
from paula.proputil.interfaces import IRWPropertyProviders


class RWPropertyProviders(Persistent, Contained):
    """Utility delivering IPropertyProviders for principal ids

    IPropertyProvider objects are generated by dynamic adapter lookup from
    IPropertyProviderAdaptable objects, which are retrieved from an internal
    mapping. Objects enter/leave the mapping through register/unregister.

    Currently we do not support modification of principal id for registered
    objects; before doing anything that modifies the prinicipal id of an object,
    you need to unregister and reregister the object.

    This utility could be registered globally and works outside of an
    application server. However, the adapter lookup for IPropertyProvider
    needs to be supported.


    Mappings are empty, for a new utility

        >>> ppu = RWPropertyProviders()
        >>> len(ppu._objs)
        0

    Suitable objects end up in the mapping, strings work as id

        >>> a = Mock(id = '1')
        >>> alsoProvides(a, IPropertyProvider)
        >>> ppu.register(a)
        >>> len(ppu._objs['1'])
        1
        >>> ppu._objs['1'][0] is a
        True

    Object with same id is appended to the same list

        >>> b = Mock(id = '1')
        >>> alsoProvides(b, IPropertyProvider)
        >>> ppu.register(b)
        >>> len(ppu._objs['1'])
        2
        >>> ppu._objs['1'][0] is a
        True
        >>> ppu._objs['1'][1] is b
        True

    Unsuitable object triggers TypeError

        >>> c = Mock(id = '2')
        >>> ppu.register(c) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
            blah
        TypeError: blah

    Object with different id enters new list

        >>> c = Mock(id = '2')
        >>> alsoProvides(c, IPropertyProvider)
        >>> ppu.register(c)
        >>> len(ppu._objs['2'])
        1
        >>> ppu._objs['2'][0] is c
        True

    Objects are retrieved correctly
        
        >>> ppu['1'][0] is a
        True
        >>> ppu['1'][1] is b
        True
        >>> ppu['2'][0] is c
        True

    has_key is working

        >>> ppu.has_key('1')
        True
        >>> ppu.has_key('0')
        False

    in operator is working

        >>> '1' in ppu
        True
        >>> '0' in ppu
        False

    list of all keys can be given

        >>> ppu.keys()
        ['1', '2']

    len() is working and contains the number of ids, we have providers for

        >>> len(ppu)
        2
    """
    implements(IRWPropertyProviders)

    def __init__(self):
        """
        """
        self._objs = queryUtility(IFactory, 'OOBTree', OOBTree.OOBTree)()

    def __contains__(self, id):
        return self.has_key(id)

    def __getitem__(self, id):
        """retrieve IPropertyProvider list for principal id
        """
        pps = [IPropertyProvider(x) for x in self._objs[id]]
        return pps

    def __len__(self):
        return self._objs.__len__()

    def has_key(self, id):
        # I currently consider this a broken BTree
        return bool(self._objs.has_key(id))

    def keys(self):
        # I currently consider this a broken BTree
        return list(self._objs.keys())

    def register(self, obj):
        """Register an object.

        It is assumed that an adapter lookup for IPropertyProvider succeeds.
        """
        id = IPropertyProvider(obj).id
        try:
            objs = self._objs[id]
        except KeyError:
            self._objs[id] = PersistentList()
            objs = self._objs[id]
        else:
            if obj in objs:
                return
        self._objs[id].append(obj)

    def unregister(self, obj):
        """Unregister an object.

        Fails with ValueError, if the object is not registered.
        """
        id = IPropertyProvider(obj).id
        self._objs[id].remove(obj)
